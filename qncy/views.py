from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import login
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.db.models import Count
from django.http import HttpResponseRedirect, HttpResponseBadRequest

from qncy.models import Question, Tag, User, Answer, QuestionVote, AnswerVote
from qncy.forms import QuestionForm, RegisterForm, AnswerForm, SettingsForm

def paginator_page(request, objects):
    # There's probably a more pythonistic way to do this
    page = 1
    try:
        page = int(request.GET.get('page', 1))
    except ValueError:
        pass
    page_size = 20
    try:
        page_size = int(request.GET.get("pagesize", 20))
    except ValueError:
        pass
    paginator = Paginator(objects, page_size)
    return paginator.get_page(page)

# This is temporary, as both blocks will eventually be generated by a script.
# And we do not fully conform to the spec (e.g. we don't check upload time)
def common_context():
    top_tags = Tag.objects.annotate(
        uses=Count('question')).order_by('-uses')[:20]
    top_users = User.objects.order_by('-rating')[:10]

    return {
        "common": {
            "top_tags": top_tags,
            "top_users": top_users
        }
    }

def index(request):
    # TODO: sorting?
    latest_question_list = Question.objects.order_by("-created_at")
    context = {
        "page_obj": paginator_page(request, latest_question_list),
    }
    return render(request, "qncy/index.html", context | common_context())

def question(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    
    answers_list = Answer.objects.filter(question=question).order_by("-accepted", "-rating")
    context = {
        "question": question,
        "page_obj": paginator_page(request, answers_list),
    }
    
    if request.user.is_authenticated:
        answer = Answer(question=question,author=request.user)
        form = AnswerForm(request.POST or None, request.FILES or None, instance=answer)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect(request.path_info)
        context['form'] = form

    return render(request, "qncy/question.html", context | common_context())

def tag(request, tag_name):
    tag = get_object_or_404(Tag, name=tag_name)
    tagged_questions_list = Question.objects.filter(tags=tag).order_by("-created_at")
    context = {
        "tag": tag,
        "page_obj": paginator_page(request, tagged_questions_list),
    }
    return render(request, "qncy/tagged.html", context | common_context())

@login_required
def ask(request):
    question = Question(author=request.user)
    form = QuestionForm(request.POST or None, request.FILES or None, instance=question)
    if form.is_valid():
        form.author_id = request.user.id
        form.save()
        return redirect("qncy:question", question_id=question.id)
    return render(request, "qncy/ask.html", {"form": form} | common_context())

def register(request):
    user = User()
    form = RegisterForm(request.POST or None, request.FILES or None, instance=user)
    if form.is_valid():
        form.save()
        login(request, user)
        return redirect("qncy:index")
    return render(request, "registration/register.html", {"form": form} | common_context())

@login_required
def settings(request):
    form = SettingsForm(request.POST or None, request.FILES or None, instance=request.user)
    if form.is_valid():
        form.save()
        return redirect("qncy:index")
    return render(request, "registration/settings.html", {"form": form} | common_context())

@login_required
def vote_question(request, question_id):
    if request.method == 'POST':
        question = get_object_or_404(Question, id=question_id)
        up = True
        if request.POST.get("up") is not None:
            up = True
        elif request.POST.get("down") is not None:
            up = False
        else:
            return HttpResponseBadRequest()
        question.vote(request.user, up)
        next = request.POST.get('next', '/')
        return HttpResponseRedirect(next)
    return HttpResponseBadRequest()

@login_required
def vote_answer(request, answer_id):
    if request.method == 'POST':
        next = request.POST.get('next', '/')
        answer = get_object_or_404(Answer, id=answer_id)
        if request.POST.get("accept") is not None:
            answer.accept(request.user)
            return HttpResponseRedirect(next)
        up = True
        if request.POST.get("up") is not None:
            up = True
        elif request.POST.get("down") is not None:
            up = False
        else:
            return HttpResponseBadRequest()
        answer.vote(request.user, up)
        return HttpResponseRedirect(next)
    return HttpResponseBadRequest()
